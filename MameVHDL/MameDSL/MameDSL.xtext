/*
 * PUBLIC DOMAIN PCCTS-BASED C++ GRAMMAR (cplusplus.g, stat.g, expr.g)
 *
 * Authors: Sumana Srinivasan, NeXT Inc.;            sumana_srinivasan@next.com
 *          Terence Parr, Parr Research Corporation; parrt@parr-research.com
 *          Russell Quong, Purdue University;        quong@ecn.purdue.edu
 *
 * VERSION 1.2
 *
 * SOFTWARE RIGHTS
 *
 * This file is a part of the ANTLR-based C++ grammar and is free
 * software.  We do not reserve any LEGAL rights to its use or
 * distribution, but you may NOT claim ownership or authorship of this
 * grammar or support code.  An individual or company may otherwise do
 * whatever they wish with the grammar distributed herewith including the
 * incorporation of the grammar or the output generated by ANTLR into
 * commerical software.  You may redistribute in source or binary form
 * without payment of royalties to us as long as this header remains
 * in all source distributions.
 *
 * We encourage users to develop parsers/tools using this grammar.
 * In return, we ask that credit is given to us for developing this
 * grammar.  By "credit", we mean that if you incorporate our grammar or
 * the generated code into one of your programs (commercial product,
 * research project, or otherwise) that you acknowledge this fact in the
 * documentation, research report, etc....  In addition, you should say nice
 * things about us at every opportunity.
 *
 * As long as these guidelines are kept, we expect to continue enhancing
 * this grammar.  Feel free to send us enhancements, fixes, bug reports,
 * suggestions, or general words of encouragement at parrt@parr-research.com.
 * 
 * NeXT Computer Inc.
 * 900 Chesapeake Dr.
 * Redwood City, CA 94555
 * 12/02/1994
 * 
 * Restructured for public consumption by Terence Parr late February, 1995.
 *
 * DISCLAIMER: we make no guarantees that this grammar works, makes sense,
 *             or can be used to do anything useful.
 */
/* 2001-2002
 * Version 1.0
 * This C++ grammar file has been converted from PCCTS to run under 
 *  ANTLR to generate lexer and parser in C++ code by
 *  Jianguo Zuo and David Wigg at
 *  The Centre for Systems and Software Engineering
 *  London South Bank University
 *  London, UK.
 *
 */
/* 2003
 * Version 2.0 was published by David Wigg in September 2003
 */
/* 2004
 * Version 3.0 July 2004
 * This is version 3.0 of the C++ grammar definition for ANTLR to 
 *  generate lexer and parser in C++ code updated by
 *  David Wigg at
 *  The Centre for Systems and Software Engineering
 *  London South Bank University
 *  London, UK.
 */
/* 2005
 * Version 3.1 November 2005
 * Updated by David Wigg at London South Bank University
 *
 */
/* 2007
 * Version 3.2 November 2007
 * Updated by David Wigg at London South Bank University
 *
 * wiggjd@bcs.ac.uk
 * blackse@lsbu.ac.uk
 *
 * See MyReadMe.txt for further information
 *
 * This file is best viewed in courier font with tabs set to 4 spaces
 */
/* -- 2010 --
 * Version 4.0.1 August 2010
 * Modified and reworked to compile with ANTLR 3.2
 *  by Ramin Zaghi
 * 
 * Please note that this is the first public release
 *  for ANTLR 3.2; This does not comiple with any older
 *  versions of ANTLR. This may also have some missing 
 *  features compared to the 2007 update by David Wigg.
 *  I am publishing this work only to make this first
 *  ANTLR 3.2 update  available  to  the  community
 *  however if you are interested in a more complete 
 *  work please take a look at David's 2007 update.
 * 
 *  I emphasize that this new update needs more work
 *  and can be restructured to make it more developer
 *  friendly. The project file is a MSVS2008 project
 *  file and it only includes a "Debug" configuration.
 *  
 *  You may send your comments to < antlr3_cpp_parser@taggedprogramming.com >
 *  
 *
 * Version 4.1.0  January 2011
 *  Functional ANTLR 3.2 parser. 
 *   Updated by Aurelian Melinte <ame01@gmx.net> with the 
 *   assistance of David Wigg<wiggjd@bcs.org.uk>
 */



grammar com.wordpress.mamevhdl.MameDSL //with org.eclipse.xtext.common.Terminals

hidden(Whitespace,Comment,CPPComment,PREPROC_DIRECTIVE,Pragma,Error,PreProcDirective)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate mameDSL "http://www.wordpress.com/mamevhdl/MameDSL"

// je pense qu'il faut le supprimer (c'est un TOKEN virtuel)
//tokens 
//{
//	OPERATOR = 'operator';
//}


//translation_unit
translation_unit returns TranslationUnit
	:	
		(externalDeclaration+=external_declaration)* // EOF
	;

//external_declaration	Note: These comment lines are provided to assist searching for productions
external_declaration returns ExternalDeclaration	
	:
	(
		// Mame GRAMMAR
		mame_root
	|
		// Template explicit specialisation
		{Template} 'template' LESSTHAN GREATERTHAN externalDeclaration=external_declaration

	|
		// All typedefs
		{TypeDef}
		(
			'typedef' enumSpecifier=enum_specifier (initDeclaratorList=init_declarator_list)? SEMICOLON
		//redondant|
		//	{TypeDefDeclaration} declaration
		|
			'typedef' classDeclOrDef=class_decl_or_def (initDeclaratorList=init_declarator_list)? SEMICOLON
		)
		
	|	
		// Class template declaration or definition
		{Template} head=template_head (functionSpecifier+=function_specifier)* classDeclOrDef=class_decl_or_def (initDeclaratorList=init_declarator_list)? SEMICOLON	// declaration
	|
		// Templated functions and constructors matched here.
		{Template} head=template_head
		(  
			// templated forward class decl, init/decl of static member in template
			declarationSpecifiers=declaration_specifiers (initDeclaratorList=init_declarator_list)? SEMICOLON
		|  
			// Templated function declaration
			declaration=declaration
		|  
			// Templated function definition
			functionDef=function_definition
		|
			// Templated constructor definition
            		// JEL 4/3/96 Added predicate that works once the
            		// restriction is added that ctor cannot be virtual
			constructorDef=ctor_definition
		)
	|  
		// Enum definition (don't want to backtrack over this in other alts)
		{Enum3} enumSpecifier=enum_specifier (initDeclaratorList=init_declarator_list)? SEMICOLON
	|
		// Destructor definition (templated or non-templated)
		{Destructor} (head=template_head)? destructorHead=dtor_head destructorBody=dtor_body
	|  
		// Constructor definition (non-templated)
		// JEL 4/3/96 Added predicate that works, once the
		// restriction is added that ctor cannot be virtual
		// and ctor_declarator uses a more restrictive id
		{Constructor} constructorDef=ctor_definition
	|  
		// User-defined type cast
		{Cast} (isInLine?=('inline'|mame_INLINE))? scopeOverride=scope_override convFunctionDeclOrDef=conversion_function_decl_or_def 
	|   
		// Function declaration
		{FunctionDecl} declSpecifiers=declaration_specifiers functionDecl=function_declarator SEMICOLON 
	|
		// Function definition
		// Function definition with int return assumed
		// K & R Function definition
		// K & R Function definition with int return assumed
		{Function} functionDef=function_definition
	|
		// Class declaration or definition
		{Class3} ('extern')? (functionSpecifiers+=function_specifier)* classDeclOrDef=class_decl_or_def (initDeclaratorList=init_declarator_list)? SEMICOLON


	


	|
		// Copied from member_declaration 31/05/07
		{Declaration} decl=declaration

	|  
		// Namespace definition
		{NameSpace} 'namespace' namespaceDef=namespace_definition
	|	
		// Semicolon
		{Nothing} SEMICOLON
		// Anything else 

	)
	;

//member_declaration
member_declaration returns MemberDeclaration
	:
	(
		// Template explicit specialisation
		{Template2} 'template' LESSTHAN GREATERTHAN memberDecl=member_declaration
	|
	
		// All typedefs
		{TypeDef2}
	 // (
		(
			'typedef' enumSpecifier=enum_specifier (initDeclaratorList=init_declarator_list)? SEMICOLON 
		|
			decl=declaration
			//SEMICOLON
		|
			'typedef' classDeclOrDef=class_decl_or_def  (initDeclaratorList=init_declarator_list)? SEMICOLON
		)
	 //)
	//)
	|  
		// Templated class declaration or definition
		{Template2} head=template_head (functionSpecifier+=function_specifier)* classDeclOrDef=class_decl_or_def (initDeclaratorList=init_declarator_list)? SEMICOLON	// declaration
	|  
		// Templated functions and constructors matched here.
		{Template2} head=template_head
		(  
			// templated forward class decl, init/decl of static member in template
			declarationSpecifiers=declaration_specifiers (initDeclaratorList=init_declarator_list)? SEMICOLON
		|
			// Templated function declaration
			declaration=declaration
		|  
			// Templated function definition
			functionDef=function_definition
		|
			// Templated constructor declarator
			constructorDeclSpec=ctor_decl_spec constructorDecl=ctor_declarator SEMICOLON
		|
			// Templated constructor definition
			// JEL 4/3/96 Added predicate that works once the
			// restriction is added that ctor cannot be virtual
			constructorDef=ctor_definition
		|
			// Templated operator function
			conversionFuncrionDeclOrDef=conversion_function_decl_or_def
		|
			// Templated class definition
			head=class_head declSpec=declaration_specifiers (initDeclaratorList=init_declarator_list)? SEMICOLON
		)
	|
		// Enum definition (don't want to backtrack over this in other alts)
		{Enum2} enumSpecifier=enum_specifier (initDeclaratorList=init_declarator_list)? SEMICOLON
	|
		// Constructor declarator
		{Constructor2} constructorDeclSpec=ctor_decl_spec constructorDecl=ctor_declarator SEMICOLON
	|  
		// JEL Predicate to distinguish ctor from function
		// This works now that ctor cannot have VIRTUAL
		// It unfortunately matches A::A where A is not enclosing
		// class -- this will have to be checked semantically
		// Constructor definition
		{Constructor2} constructorDef=ctor_definition 
	|  
		// No template_head allowed for dtor member
		// Backtrack if not a dtor (no TILDE)
		// Destructor declaration
		{Desstructor2} head=dtor_head SEMICOLON
	|//
		// No template_head allowed for dtor member
		// Backtrack if not a dtor (no TILDE)
		// Destructor definition
		{Desstructor2} head=dtor_head body=dtor_body

	|
		// Function declaration
		{FunctionDecl2} declSpecifiers=declaration_specifiers functionDecl=function_declarator SEMICOLON
	
	|  
		// Function definition
		{Function2} functionDef=function_definition
	////	
	|
		// Class declaration or definition
		{Class2} (isFriend?='friend')? (functionSpec+=function_specifier)* classDeclOrDef=class_decl_or_def (initDeclList=init_declarator_list)? SEMICOLON
	| 
		{Declaration2} decl=declaration //HERE//
	|
		// Member without a type (I guess it can only be a function declaration or definition)
		{FunctionDecl2} (functionSpec+=function_specifier)* functionDecl=function_declarator SEMICOLON
	|
		// Member without a type (I guess it can only be a function definition)
		{FunctionDecl2} (functionSpec+=function_specifier)* functionDecl=function_declarator compoundStatement=compound_statement
	|
		// User-defined type cast
		{Cast2} (isInLine?=('inline'|mame_INLINE))? convFunctionDeclOrDef=conversion_function_decl_or_def
	|  
		// Hack to handle decls like "superclass::member",
		// to redefine access to private base class public members
		// Qualified identifier
		qualifiedId=qualified_id SEMICOLON
	////	
	|
		// Access specifier  
		accessSpecifier=access_specifier COLON
	|
		// Semicolon
		{Nothing2} SEMICOLON
	)
	;
	
 

//namespace_definition
namespace_definition returns NamespaceDef
	:
		(id=ID)?
		LCURLY 
		(externalDecl+=external_declaration)*
		RCURLY
	;

//namespace_alias_definition
namespace_alias_definition returns NamespaceAliasDef
	:
		'namespace'
		id=ID 
		ASSIGNEQUAL qualifiedId=qualified_id SEMICOLON 
	;

//function_definition
function_definition returns FunctionDefinition
	:
	(	// Next line is equivalent to guarded predicate in PCCTS
		// (SCOPE | ID)? => <<qualifiedItemIsOneOf(qiType|qiCtor)>>?
		declSpec=declaration_specifiers? functionDecl=function_declarator
		(	
			(decl+=declaration)*	// Possible for K & R definition
		)?
		compoundStatement=compound_statement
	)
	;

//declaration
declaration returns Declaration
	:	
		linkage_specification //cas unique
	|	
		simple_declaration // tout ce qui parle de Declaration sera de type Declaration
	|	
		using_statement //cas unique
	;


//linkage_specification
linkage_specification returns LinkageSpecification
	:	
		'extern'
		value=StringLiteral
		(LCURLY (externalDecl+=external_declaration)* RCURLY
		|decl=declaration
		)
	;

//class_head
class_head returns ClassHead
	:	// Used only by predicates
		(type='struct'
		|type='union' 
		|type='class' 
		)
		(id=ID	
			(LESSTHAN templateArgumentList=template_argument_list GREATERTHAN)?
			(baseClause=base_clause)? 
		)? 
		LCURLY
	;

//declaration_specifiers
declaration_specifiers returns DeclarationSpecifier
	:
	(	
		(
			type+='typedef'	
		|	type+='friend'	
		|	type+=storage_class_specifier 	// auto,register,static,extern,mutable
		|	type+=type_qualifier          	// const,volatile	// aka cv_qualifier See type_qualifier
		|	type+=function_specifier      	// inline,virtual,explicit
		|	type+=('_declspec'|'__declspec') LPAREN ID RPAREN 
		)* 
		typeSpecifier=type_specifier    
		(typeQualifier+=type_qualifier	)*	// const,volatile	// aka cv_qualifier See type_qualifier
	)
	;


//storage_class_specifier
storage_class_specifier returns ecore::EString
	:	'auto'		
	|	'register'	
	|	'static'	
	|	'extern'	
	|	'mutable'	
	;


//function_specifier
function_specifier returns ecore::EString
	:	('inline'|'_inline'|'__inline'|mame_INLINE)
	|	'virtual'			
	|	'explicit'			
	;

//type_specifier
type_specifier returns SimpleTypeSpecifier
	:	
		simple_type_specifier
	;




/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////


//simple_type_specifier
simple_type_specifier returns SimpleTypeSpecifier
	:
		(
			 qualifiedType=qualified_type
		|
		//lbl_ts changed by V3-Author
			type+=('typename'|'enum'| class_specifier) 
			 qualifiedType=qualified_type
		|	
			type+=(	'char'		
			|	'wchar_t'	
			|	'bool'		
			|	'short'		
			|	'int'		
			|	('_int8'|'__int8')		
			|	('_int16'|'__int16')	
			|	('_int32'|'__int32')	
			|	('_int64'|'__int64')	
			|	('_w64'|'__w64')		
			|	'long'		
			|	'signed'	
			|	'unsigned'	
			|	'float'		
			|	'double'	
			|	'void'		
			)+
		)
		//)
	;

//qualified_type
qualified_type returns QualifiedType
	: 
		// JEL 3/29/96 removed this predicate and moved it upwards to
		// simple_type_specifier.  This was done to allow parsing of ~ID to 
		// be a unary_expression, which was never reached with this 
		// predicate on

		scopeOverride=scope_override
		id=ID 
		(
		 
		 LESSTHAN templateArgumentList=template_argument_list GREATERTHAN
		)?
	;

//class_specifier
class_specifier returns ecore::EString
	:	
		('class'	
		|'struct'	
		|'union'	
		)
	;

//type_qualifier
type_qualifier returns ecore::EString
	:  
		('const'	
		|'volatile'	
		)
	;


//class_decl_or_def
class_decl_or_def returns ClassDeclOrDef
	:	
		type=('class'	
		|'struct'	
		|'union'	
		)
		(('_declspec'|'__declspec') LPAREN declSpec+=expression RPAREN)*	// Temp for Evgeniy
		(	qualifiedId=qualified_id
			(
				// Empty 
//			|
				(baseClause=base_clause)?
				LCURLY
				(memberDecl+=member_declaration)*
				RCURLY
			)?
		|
			LCURLY
			(memberDecl+=member_declaration)*
			RCURLY
		)
	;

//base_clause
base_clause returns BaseCause
	:	
		COLON baseSpec+=base_specifier (COMMA baseSpec+=base_specifier)*
	;

//base_specifier
base_specifier returns BaseSpecifier
	:	
		(	isVirtual?='virtual' (accessSpecifier=access_specifier)? qualifiedType=qualified_type
		|	accessSpecifier=access_specifier (isVirtual?='virtual')? qualifiedType=qualified_type
		|	qualifiedType=qualified_type
		)
	;

//access_specifier
access_specifier returns ecore::EString
	:	
		(	'public'
		|	'protected'
		|	'private'
		)
	;

//enum_specifier
enum_specifier returns EnumSpecifier
	:	
		'enum'
		(	
			LCURLY enumList=enumerator_list RCURLY
		|	
			qualifiedId=qualified_id
			(LCURLY enumList=enumerator_list RCURLY)?
		)
	;

//enumerator_list
enumerator_list returns EnumeratorList
	:	
		enumerator+=enumerator (COMMA (enumerator+=enumerator)? )*	// Allows comma at end of list
	;

//enumerator
enumerator returns Enumerator
	:	
		id=ID (ASSIGNEQUAL constantExpression=constant_expression)?
	;




// This matches a generic qualified identifier ::T::B::foo
 // (including OPERATOR).
 // It might be a good idea to put T::~dtor in here
 // as well, but id_expression in expr.g puts it in manually.
 // Maybe not, 'cause many people use this assuming only A::B.
 // How about a 'qualified_complex_id'?
//
//qualified_id
qualified_id returns QualifiedId
	:	
		scopeOverride=scope_override
		(	id=ID 
			(LESSTHAN templateArgumentList=template_argument_list GREATERTHAN)?
//		|  
			//OPERATOR 
// les parametres et tout le bazard
//operator=optor
		|
			TILDE idExpression=id_expression		// 1/08/07
		)
	;

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////


//typeID
typeID returns ecore::EString
	:	
		ID
	;

//init_declarator_list
init_declarator_list returns InitDeclList
	:	
		memberDecl+=member_declarator (COMMA memberDecl+=member_declarator)*
	;

//member_declarator
member_declarator returns MemberDeclarator
	:	
		{MemberDeclaratorColon} (id=ID)? COLON constantExpression=constant_expression
	|  
		{MemberDeclaratorDeclarator} decl=declarator
		(
			ASSIGNEQUAL valueZero=OCTALINT	// The value must be zero (for pure virtual)
		|	
			ASSIGNEQUAL 
			value=initializer
		|	
			LPAREN exprList=expression_list RPAREN // member function / method declaration
		)?
	;

//initializer
initializer returns Initializer
	:	
		remainderExpr=remainder_expression	// assignment_expression
	|	
		LCURLY init+=initializer (COMMA (init+=initializer)? )* RCURLY	// Allows comma at end of list
	;

//declarator
declarator returns Declarator
	:
		ptr=ptr_operator	// AMPERSAND or STAR etc.
		decl=declarator
	|	
		direct_declarator
	;

//direct_declarator
direct_declarator returns Declarator
	:	// Mame GRAMMAR
		mame_terminals
	|
			// Must be function declaration
		qualifiedId=qualified_id
		LPAREN
		(paramList=parameter_list)?
		RPAREN
		(typeQualifier+=type_qualifier)*
		(exceptionSpec=exception_specification)?
	|	
			// Must be class instantiation
		qualifiedId=qualified_id
		LPAREN
		expressionList=expression_list
		RPAREN
	|
			// Must be array declaration
		qualifiedId=qualified_id
		(
		 LSQUARE (constantExpr+=constant_expression)? RSQUARE)+
	|
			// Must be function declaration (see function_direct_declarator)
		qualifiedId=qualified_id
	|	
		LPAREN declarator=declarator RPAREN 
		(
		 declaratorSuffix=declarator_suffix)? // DW 1/9/04 declarator_suffix made optional as failed on line 2956 in metrics.i
	;					// According to the grammar a declarator_suffix is not required here

//declarator_suffix
declarator_suffix returns DeclaratorSuffix		// Note: Only used above in direct_declarator
	:
	(	
		(LSQUARE (constantExpr+=constant_expression)? RSQUARE)+
	|	
		LPAREN 
		(paramList=parameter_list)?
				RPAREN 
		(typeQualifier+=type_qualifier)*
		(exceptionSpec=exception_specification)?
	)
	;



//conversion_function_decl_or_def
conversion_function_decl_or_def returns ConversionFunctionDeclOrDef
	:
		//OPERATOR 
declSpec=declaration_specifiers type=(STAR | AMPERSAND)?	// DW 01/08/03 Use type_specifier here? see syntax
		( LESSTHAN templateParamList=template_parameter_list GREATERTHAN  )?
		LPAREN (paramList=parameter_list)? RPAREN
		(typeQualifiers+=type_qualifier)*	// DW 29/07/05 ? changed to *
		(exceptionSpec=exception_specification)?
		(	compoundStatement=compound_statement
		|	SEMICOLON
		)
	;

 //function_declarator
function_declarator returns FunctionDeclarator
	:	
		ptr=ptr_operator fctDecl=function_declarator
	|	
		function_direct_declarator
	;

//function_direct_declarator
function_direct_declarator returns FunctionDeclarator
	:
		(	// fix prompted by (isdigit)() in xlocnum
			LPAREN 
			declarator=declarator
			RPAREN
		|
			qualifiedId=qualified_id
		)


		LPAREN 
		(paramList=parameter_list)? 
		RPAREN
		(typeQualified+=type_qualifier)*
		(ASSIGNEQUAL valueZero=OCTALINT)?	// The value of the octal must be 0
		(exceptionSpec=exception_specification)?
	;






/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////

//ctor_definition
ctor_definition returns ConstructorDef
	:
		head=ctor_head
		body=ctor_body
	;

//ctor_head
ctor_head returns ConstructorHead
	:
		declSpec=ctor_decl_spec
		decl=ctor_declarator
	;

//ctor_decl_spec
ctor_decl_spec returns ConstructorDeclSpec
	:
		types+=(('inline'|'_inline'|'__inline'|mame_INLINE)|'explicit')*
	;

//ctor_declarator
ctor_declarator returns ConstructorDeclarator
	: 
		qualifiedId=qualified_ctor_id
		LPAREN (paramList=parameter_list)? RPAREN
		(exceptionSpec=exception_specification)?
	;


// This matches a generic qualified identifier ::T::B::foo
// that is satisfactory for a ctor (no operator, no trailing <>)
qualified_ctor_id returns QualifiedConstructorId
	: 
		scopeOverride=scope_override
		id=ID	// DW 24/05/04 Note. Neither Ctor or Dtor recorded in dictionary
	;

//ctor_body
ctor_body returns ConstructorBody
	:
		(init=ctor_initializer)?
		compountStatement=compound_statement
	;

//ctor_initializer
ctor_initializer returns ConstructorInit
	:
		COLON init+=superclass_init (COMMA init+=superclass_init)*
	;

//superclass_init
superclass_init returns SuperclassInit
	: 
		qualifiedId=qualified_id LPAREN (exprList=expression_list)? RPAREN
	;

//dtor_head
dtor_head returns DestructorHead
	:
		declSpec=dtor_decl_spec
		decl=dtor_declarator
	;

//dtor_decl_spec
dtor_decl_spec returns DestructorDeclSpec
	:
		(type+=('inline'|'_inline'|'__inline'|mame_INLINE|'virtual')*)
	;

//dtor_declarator
dtor_declarator returns DestructorDecl
	:	
		scopeOverride=scope_override
		TILDE id=ID
		LPAREN isVoid?=('void')? RPAREN
		(exceptionSpec=exception_specification)?
	;

//dtor_body
dtor_body returns DestructorBody
	:
		compoundStatement=compound_statement
	;

//parameter_list
parameter_list returns ParamList
	:	
		parameter_declaration_list (ELLIPSIS)?
	;

//parameter_declaration_list
parameter_declaration_list returns ParamList
	:	
		(paramDecl+=parameter_declaration (COMMA paramDecl+=parameter_declaration)* )
	;

//parameter_declaration	(See also template_parameter_declaration) 
parameter_declaration returns ParamDecl
	:	
		(
			
			declarationSpec=declaration_specifiers	// DW 24/3/98 Mods for K & R
			(  
				decl=declarator        // if arg name given
			| 
				abstractDecl=abstract_declarator     // if arg name not given  // can be empty
			)
		|
					decl=declarator			// DW 24/3/98 Mods for K & R
		|
			ELLIPSIS
		)
		(ASSIGNEQUAL 
		 remainderExpr=remainder_expression // DW 18/4/01 assignment_expression
		)?
	;

//type_id
type_id returns TypeId
	:
		declSpec=declaration_specifiers abstractDecl=abstract_declarator
	;

// This rule looks a bit weird because (...) can happen in two
// places within the declaration such as "void (*)()" (ptr to
// function returning nothing).  However, the () of a function
// can only occur after having seen either a (abstract_declarator)
// and not after a or simple '*'.  These are the only two
// valid () func-groups:
//    int (*)();     // ptr to func
 //
//abstract_declarator
abstract_declarator returns AbstractDecl
	:	
		ptr=ptr_operator abstractDecl=abstract_declarator 
	|	
		LPAREN abstractDecl=abstract_declarator RPAREN
		(abstractDeclSuffix=abstract_declarator_suffix)
	|	
		(abstractDeclSuffix=abstract_declarator_suffix)?
	;

//abstract_declarator_suffix
abstract_declarator_suffix returns AbstractDeclSuffix
	:	
		(LSQUARE (constantExpr+=constant_expression)? RSQUARE)+
	|
		LPAREN
		(paramList=parameter_list)?
		RPAREN
		cvQualifierSeq=cv_qualifier_seq
		(exceptionSpec=exception_specification)?
	;

//exception_specification
exception_specification returns ExceptionSpecification
	:	
		'throw'
		LPAREN 
		(	(scopeOverrides+=scope_override ids+=ID (COMMA scopeOverrides+=scope_override ids+=ID)* )? 
		|	ELLIPSIS
		)
		RPAREN
	;

//template_head
template_head returns Template
	:	
		'template'
		LESSTHAN templateParamList=template_parameter_list GREATERTHAN
	;

//template_parameter_list
template_parameter_list returns TemplateParamList
	:	
		params+=template_parameter (COMMA params+=template_parameter)*
	;

// Rule requires >2 lookahead tokens. The ambiguity is resolved 
// correctly, however. According to the manual "...A template argument
// that can be interpreted either as a parameter-declaration or a
// type-argument (because its identifier is the name of an
// already existing class) is taken as type-argument."
// Therefore, any "class ID" that is seen on the input, should
// match the first alternative here (it should be a type-argument).
 //
//template_parameter
template_parameter returns TemplateParam
	:	
		(
		 typeParam=type_parameter
		|
		  paramDecl=parameter_declaration //owned !
		|
		 templateParamDecl=template_parameter_declaration
		)
	;

//type_parameter
type_parameter returns TypeParam
	:
		(	
			type=('class'|'typename') 
			(id=ID
				(ASSIGNEQUAL assignedTypeName=assigned_type_name)?
			)?
		|
			head=template_head type='class' 
			(id=ID
				(ASSIGNEQUAL assignedTypeName=assigned_type_name)?
			)?
		)
	;

// This is to allow an assigned type_name in a template parameter
//	list to be defined previously in the same parameter list,
//	as type setting is ineffective whilst guessing
 //
//assigned_type_name
assigned_type_name returns AssignedTypeName
	:
		(
			qualifiedType=qualified_type abstractDecl=abstract_declarator
		|
			simpleTypeSpec=simple_type_specifier abstractDecl=abstract_declarator
		)
	;

//template_parameter_declaration	(See also parameter_declaration)
template_parameter_declaration returns TemplateDeclarationParam
	:	
		(
			
			declarationSpec=declaration_specifiers	// DW 24/3/98 Mods for K & R
			(  
				decl=declarator        // if arg name given
			| 
				abstractDecl=abstract_declarator     // if arg name not given  // can be empty
			)
		|
			decl=declarator			// DW 24/3/98 Mods for K & R
		|
			ELLIPSIS
		)
		(ASSIGNEQUAL
		 additiveExpr=additive_expression	// DW 04/09/07 because of ambiguity of ">"
		)?
	;

// This rule refers to an instance of a template class or function
//template_id
template_id returns TemplateId	// aka template_class_name
	:	
		id=ID LESSTHAN templateArgList=template_argument_list GREATERTHAN
	;

//template_argument_list
template_argument_list returns TemplateArgList
	:	
		templateArg+=template_argument (COMMA templateArg+=template_argument)*
	;

// Here assignment_expression was changed to shift_expression to rule out
//  x< 1<2 > which causes ambiguities. As a result, these can be used only
//  by enclosing parentheses x<(1<2)>. This is true for x<1+2> ==> bad,
//  x<(1+2)> ==> ok.
 //
//template_argument
template_argument returns TemplateArg
	:
		// DW 07/04/05 This predicate only used here if next is SCOPE or ID
		typeId=type_id
	|	
		shiftExpr=shift_expression // failed in iosfwd
	;



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//////////////////////////////  STATEMENTS ////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

//statement_list
statement_list returns StatementList
	:	
		(statement+=statement)+
	;

//statement
statement returns Statement
	:
		(	
			block_declaration
		|	
			 member_declaration
		|	
			 member_declaration
		|	 
			 labeled_statement
		|	 case_statement
		|	 default_statement 
		|	 expression SEMICOLON
		|	 compound_statement
		|	 selection_statement
		|	 iteration_statement
		|	 jump_statement
		|	 SEMICOLON
		|	 try_block
		|	 throw_statement
		)
	
	;

//block_declaration
block_declaration returns Declaration
	:	simple_declaration
	|	namespace_alias_definition
	|	using_statement
	;

//simple_declaration
simple_declaration returns Declaration
	:
		declSpec=declaration_specifiers (initDeclList=init_declarator_list)? SEMICOLON
	;

//labeled_statement
labeled_statement returns LabeledStatement
	:	
		id=ID COLON statement=statement
	;

//case_statement
case_statement returns CaseStatement
	:	'case'
		cosntantExpr=constant_expression COLON statement=statement
	;

//default_statement
default_statement returns DefaultStatement
	:	
		'default' COLON statement=statement
	;

//compound_statement
compound_statement returns CompoundStatement
	:	
		LCURLY 
		(statementList=statement_list)?
		RCURLY 
	;

// NOTE: cannot remove ELSE ambiguity, but it parses correctly.
// The warning is removed with the options statement
///
//selection_statement
selection_statement returns SelectionStatement
	:	
		'if' LPAREN 
		if=condition RPAREN
		then=statement
		(
		 'else' else=statement)?
	|	
		'switch' LPAREN
		switchCondition=condition RPAREN switchStatement=statement
	;

//iteration_statement
iteration_statement returns IterationStatement
	:	
		'while'	LPAREN
		whileCondition=condition RPAREN 
		whileStatement=statement  
	|	
		'do' 
		dowhileStatment=statement 'while'
		LPAREN dowhileCondition=expression RPAREN 
		SEMICOLON
	|	
		'for' LPAREN
		(	forDecl=declaration 
		|	(forExpr=expression)? SEMICOLON
		)
		(forCondition=condition)? SEMICOLON
		(forExpr2=expression)?
		RPAREN forStatement=statement	 
	;

//condition
condition returns Condition
	:
		(	
			 declSpec=declaration_specifiers decl=declarator ASSIGNEQUAL remainderExpr=remainder_expression
		|	expr=expression
		)
	;

//jump_statement
jump_statement returns JumpStatement
	:	
		(	type='goto' goto=ID SEMICOLON
		|	type='continue' SEMICOLON
		|	type='break' SEMICOLON
		|	// DW 16/05/03 May be problem here if return is followed by a cast expression 
			type='return'
			(	
			                                       // THE ,0 was added by V3-Author
				
				LPAREN id=ID RPAREN (expr=expression)?	// This is an unsatisfactory fix for problem in xstring re 'return (allocator);'
												//  and in xlocale re return (_E)(_Tolower((unsigned char)_C, &_Ctype));
			|	expr=expression 
			)?	SEMICOLON
		)
	;

//try_block
try_block returns TryBlock
	:	
		'try' compoundStatement=compound_statement (handler+=handler)*
	;

//handler
handler returns Handler
	:	
		'catch'
		LPAREN exceptionDecl=exception_declaration RPAREN
		compoundStatement=compound_statement
	;

//exception_declaration
exception_declaration returns ExceptionDecl
	:	
		paramDeclList=parameter_declaration_list
	;

// This is an expression of type void according to the ARM, which
// to me means "statement"; it removes some ambiguity to put it in
// as a statement also.
///
//throw_statement
throw_statement returns ThrowStatement
	:	
		'throw' (assignExpr=assignment_expression) ? SEMICOLON
	;

//using_statement
using_statement returns UsingStatement
	:		
		'using'
		(type='namespace' qualifiedId=qualified_id		// Using-directive
		|(type='typename')? qualifiedId=qualified_id	// Using-declaration
		)
		SEMICOLON
	;


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//////////////////////////////  EXPRESSIONS ///////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

// Same as expression_list
//expression
expression returns Expression
	:
		assignment_expression ({Expression.expr=current} op+=COMMA exprs+=assignment_expression (op+=COMMA exprs+=assignment_expression)*)?
	;

// right-to-left for assignment op
//assignment_expression
assignment_expression returns AssignementExpression
	:
		conditional_expression
		( {AssignementExpression1.expr=current} 
			op+=(ASSIGNEQUAL|TIMESEQUAL|DIVIDEEQUAL|MINUSEQUAL|PLUSEQUAL
			|MODEQUAL|SHIFTLEFTEQUAL|SHIFTRIGHTEQUAL|BITWISEANDEQUAL
			|BITWISEXOREQUAL|BITWISEOREQUAL)
			exprs+=remainder_expression
		)?
| mame_statement // principalement les interfaces
	;


//remainder_expression
remainder_expression returns RemainderExpression
	:
		assignment_expression
//| mame_statement // principalement les interfaces
	;

//conditional_expression
conditional_expression returns ConditionalExpression
	:
		logical_or_expression
		({ConditionalExpression.expr=current} op+=QUESTIONMARK exprs+=expression op+=COLON exprs+=conditional_expression)?
	;

//constant_expression
constant_expression returns ConstantExpression
	:	
		conditional_expression
	;

//logical_or_expression
logical_or_expression returns LogicalOrExpression
	:	
		logical_and_expression ({LogicalOrExpression.expr=current} op+=OR exprs+=logical_and_expression (op+=OR exprs+=logical_and_expression)*)?
	;

//logical_and_expression
logical_and_expression returns LogicalAndExpression
	:	
		inclusive_or_expression ({LogicalAndExpression.expr=current} op+=AND exprs+=inclusive_or_expression (op+=AND exprs+=inclusive_or_expression)*)?
	;

//inclusive_or_expression
inclusive_or_expression returns InclusiveOrExpression
	:	
		exclusive_or_expression ({InclusiveOrExpression.expr=current} op+=BITWISEOR exprs+=exclusive_or_expression (op+=BITWISEOR exprs+=exclusive_or_expression)*)?
	;

//exclusive_or_expression
exclusive_or_expression returns ExclusiveOrExpression
	:	
		and_expression ({ExclusiveOrExpression.expr=current} op+=BITWISEXOR exprs+=and_expression (op+=BITWISEXOR exprs+=and_expression)*)?
	;

//and_expression
and_expression returns AndExpression
	:	
		equality_expression ({AndExpression.expr=current} op+=AMPERSAND exprs+=equality_expression (op+=AMPERSAND exprs+=equality_expression)*)?
	;

//equality_expression
equality_expression returns EqualityExpression
	:	
		relational_expression ({EqualityExpression.expr=current} op+=(NOTEQUAL|EQUAL) exprs+=relational_expression (op+=(NOTEQUAL|EQUAL) exprs+=relational_expression)*)?
	;

//relational_expression
relational_expression returns RelationalExpression
	:	
		shift_expression
		({RelationalExpression.expr=current}
			op+=(LESSTHAN | GREATERTHAN | LESSTHANOREQUALTO | GREATERTHANOREQUALTO)
			exprs+=shift_expression
		)?
	;

//shift_expression
shift_expression returns ShiftExpression
	:	
		additive_expression ({ShiftExpression.expr=current} op+=(SHIFTLEFT | SHIFTRIGHT) exprs+=additive_expression (op+=(SHIFTLEFT | SHIFTRIGHT) exprs+=additive_expression)*)?
	;

// See comment for multiplicative_expression regarding #pragma
additive_expression returns AdditiveExpression
	:	
		multiplicative_expression
		( {AdditiveExpression.expr=current}
			op+=(PLUS | MINUS) exprs+=multiplicative_expression (op+=(PLUS | MINUS) exprs+=multiplicative_expression)*
		)?
	;

// ANTLR has trouble dealing with the analysis of the confusing unary/binary
// operators such as STAR, AMPERSAND, PLUS, etc...  
// With the #pragma 
// we simply tell ANTLR to use the "quick-to-analyze" approximate lookahead
// as full LL(k) lookahead will not resolve the ambiguity anyway.  Might
// as well not bother.  This has the side-benefit that ANTLR doesn't go
// off to lunch here (take infinite time to read grammar).
multiplicative_expression returns MultiplicativeExpression
	:	
		pm_expression
		( {MultiplicativeExpression.expr=current}
			op+=(STAR|DIVIDE|MOD) exprs+=pm_expression (op+=(STAR|DIVIDE|MOD) exprs+=pm_expression)*
		)?
	;

//pm_expression
pm_expression returns PmExpression
	:	
		cast_expression ( {PmExpression.expr=current} op+=(DOTMBR|POINTERTOMBR) exprs+=cast_expression (op+=(DOTMBR|POINTERTOMBR) exprs+=cast_expression)*)?
	;

// The string "( ID" can be either the start of a cast or
///the start of a unary_expression.  However, the ID must
// be a type name for it to be a cast.  Since ANTLR can only hoist
// semantic predicates that are visible without consuming a token,
// the semantic predicate in rule type_name is not hoisted--hence, the
// rule is reported to be ambiguous.  I am manually putting in the
// correctly hoisted predicate.
//
// Ack! Actually "( ID" might be the start of "(T(expr))" which makes
// the first parens just an ordinary expression grouping.  The solution
// is to look at what follows the type, T.  Note, this could be a
// qualified type.  Yucko.  I believe that "(T(" can only imply
// function-style type cast in an expression (...) grouping.
//
// We DO NOT handle the following situation correctly at the moment:
// Suppose you have
//    struct rusage rusage;
//    return (rusage.fp);
//    return (rusage*)p;
// Now essentially there is an ambiguity here. If rusage is followed by any
// postix operators then it is an identifier else it is a type name. This
// problem does not occur in C because, unless the tag struct is attached,
// rusage is not a type name. However in C++ that restriction is removed.
// No *real* programmer would do this, but it's in the C++ standard just for
// fun..
//
// Another fun one (from an LL standpoint):
//
//   (A::B::T *)v;      // that's a cast of v to type A::B::T
//   (A::B::foo);    // that's a simple member access
//
// The qualifiedItemIs(1) function scans ahead to what follows the
// final "::" and returns qiType if the item is a type.  The offset of
// '1' makes it ignore the initial LPAREN; normally, the offset is 0.
 //

//cast_expression
cast_expression  returns CastExpression // ne peut pas couper la branche ici à cause de TypeID
	: 
		// Believe it or not, you can get more than one cast expression in sequence
		 (LPAREN exprs+=type_id RPAREN)+ expr=cast_expression
	|  
		unary_expression	// handles outer (...) of "(T(expr))"
	;


//unary_expression
unary_expression returns UnaryExpression
	: 
		(	
			postfix_expression
		|	
			{UnaryExpression} op+=(PLUSPLUS|MINUSMINUS) expr=unary_expression
		|	
			{UnaryExpression} op+=unary_operator expr=cast_expression
		|	{UnaryExpression}
			op+=('sizeof'
			|'__alignof__' 	//Zhaojz 02/02/05 to fix bug 29 (GNU)
			)
			(	
				expr=unary_expression
			|
				LPAREN expr=type_id RPAREN
			)
		|   new_expression|delete_expression
		|
			{UnaryExpression} op+=SCOPE expr=(new_expression|delete_expression)
		)
	;


//postfix_expression
postfix_expression returns PostfixExpression
	:	//compo1 returns Compo1 : compo2 ( {Compo1.expr=current}  op+=(‘-’|'+’) exprs+=compo2  (op+=(‘-’|'+’) exprs+=compo2)*)?;
/*		simpleTypeSpec=simple_type_specifier LPAREN
		//freemac (
		//freemac RPAREN LPAREN (exprList+=expression_list)? RPAREN // DW 01/08/03 To cope with problem in xtree (see test10.i)
		//freemac |
		(exprList+=expression_list)? RPAREN
		// Following put in to allow for the above being a constructor as shown in test_constructors_destructors.cpp
		(DOT postfixExpr=postfix_expression)?
		//freemac )
	|  */
		primary_expression // : ambigus Left Recursive
		({PostfixExpression.expr=current} (op+=LSQUARE exprs+=expression RSQUARE
			 |	op+=LPAREN (exprs+=expression_list)? RPAREN // function call/function-call or method call/method-call.
			 |	op+=(DOT|POINTERTO) ('template')? exprs+=id_expression
			 |	op+=PLUSPLUS
			 |	op+=MINUSMINUS
			)
			(op+=LSQUARE exprs+=expression RSQUARE
			 |	op+=LPAREN (exprs+=expression_list)? RPAREN // function call/function-call or method call/method-call.
			 |	op+=(DOT|POINTERTO) ('template')? exprs+=id_expression
			 |	op+=PLUSPLUS 
			 |	op+=MINUSMINUS
			)*
		)?
	|
		{PostfixExpression} op+=('dynamic_cast'|'static_cast'|'reinterpret_cast'|'const_cast')
		LESSTHAN (isConst?='const')? typeSpec=type_specifier (ptrOp=ptr_operator)? GREATERTHAN
		LPAREN exprs+=expression RPAREN
	|
		{PostfixExpression} op+='typeid' 
		LPAREN exprs+=(type_id|expression) RPAREN
		( op+=(DOT|POINTERTO) exprs+=postfix_expression)?
	
	;

//primary_expression
primary_expression returns PrimaryExpression
	:	id_expression
	|	id=literal
	|	id='this'
	|	{Group} LPAREN expr=expression RPAREN
	| 	id=mame_terminals // Mame GRAMMAR
	|	func=mame_function // Mame GRAMMAR
	|       interrupt=mame_interrupt // Mame GRAMMAR
	; 

//id_expression
id_expression  returns IdExpression
	:
		qualified_id
	;

//literal
literal returns ecore::EString
	:
	(	OCTALINT
	|	DECIMALINT
	|	HEXADECIMALINT
	|	CharLiteral
	|	WCharLiteral
	|	(StringLiteral|WStringLiteral)+
	|	FLOATONE
	|	FLOATTWO
	|	'true'
	|	'false')
	
	;

//unary_operator
unary_operator returns ecore::EString
	:
	AMPERSAND
	|	STAR
	|	PLUS
	|	MINUS
	|	TILDE
	|	NOT
	;


// JEL The first ()? is used to resolve "new (expr) (type)" because both
// (expr) and (type) look identical until you've seen the whole thing.
//
// new_initializer appears to be conflicting with function arguments as
// function arguments can follow a primary_expression.  This is a full
// LL(k) versus LALL(k) problem.  Enhancing context by duplication of
// some rules might handle this.
///
//new_expression
new_expression returns NewExpression
	:
	(  
		'new'
		(	
			 LPAREN exprList=expression_list RPAREN)?
		(
		LPAREN typeId=type_id RPAREN
		|newTypeId=new_type_id)
		(init=new_initializer)?
	)
	;

//new_initializer
new_initializer returns NewInitializer
	:	
		LPAREN (exprList=expression_list)? RPAREN
	;

//new_type_id
new_type_id returns NewTypeId
	:	
		declSpecs=declaration_specifiers 
		(
			decl=new_declarator
		)?
	;

//new_declarator
new_declarator returns NewDeclarator
	:	 
		ptr=ptr_operator
		(decl=new_declarator)?
	|	
		declDirect=direct_new_declarator
	;

// by token that can begin an expression, we always want to loop.
// Approximate lookahead handles this correctly.  In fact, approximate
// lookahead is the same as full lookahead when all but the last lookahead
// depth are singleton sets; e.g., followed by FIRST(expression).
///
//direct_new_declarator
direct_new_declarator returns DirectNewDeclarator
	:
		(
			(LSQUARE exprs+=expression RSQUARE)
		)+
	;


//ptr_operator
ptr_operator returns PtrOperator
	:	
			 AMPERSAND 	
		|	 type=('_cdecl'|'__cdecl') 
		|	 type=('_near'|'__near') 
		|	 type=('_far'|'__far') 
		|	 type='__interrupt' 
		|	 type=('pascal'|'_pascal'|'__pascal') 
		|	 type=('_stdcall'|'__stdcall') 
		|	
			 scopeOverride=scope_override STAR cvQualifier_seq=cv_qualifier_seq
		
		
			
   ;
   
  

// Match A::B::*	// May be redundant 14/06/06
//ptr_to_member
ptr_to_member	 returns PtrToMember// Part of ptr_operator in grammar.txt
	:
		scopeOverride=scope_override STAR cvQualifierSeq=cv_qualifier_seq
	;

// JEL note:  does not use (const|volatile)* to avoid lookahead problems
//cv_qualifier_seq
cv_qualifier_seq returns ecore::EString
	:
		(type_qualifier)*
	;


// Match "(::)A::B::C::(template)" or just "::"
//scope_override  // DW 28/11/10 Otherwise known as nested-name-specifier 
scope_override returns ScopeOverride
	:
		(SCOPE  )? 
		(	
			id+=ID 
			LESSTHAN templateArgList+=template_argument_list GREATERTHAN
			SCOPE 
			('template')?
			
		|	
			
			id+=ID 
			SCOPE 
			('template' )?
			
		)*
	;



//delete_expression
delete_expression returns DeleteExpression
	:	
		'delete' (LSQUARE RSQUARE)? castExpr=cast_expression
	;

// Same as expression
//expression_list
expression_list returns ExpressionList
	:	
		assignExpr+=assignment_expression (COMMA assignExpr+=assignment_expression)*
	;

//optor
optor returns Optor
	:	// NOTE: you may need to add backtracking depending on the C++ standard specifications used...
		// but for now V3-Author has decided not to add that and go for the default alternative 1 selected
		// during antlr code generation...
		(	type='new'
			(
				LSQUARE RSQUARE  )?
		|   
			type='delete'
			(
				LSQUARE RSQUARE  )?
		|	
			LPAREN RPAREN  
		|	
			LSQUARE RSQUARE
		|
			optorSimple=optor_simple_tokclass
		|
			typeSpec=type_specifier LPAREN RPAREN
		)
	;


// optor_simple_tokclass
optor_simple_tokclass returns ecore::EString
	:
    	 PLUS|MINUS|STAR|DIVIDE|MOD|BITWISEXOR|AMPERSAND|BITWISEOR|TILDE|NOT|
	 SHIFTLEFT|SHIFTRIGHT|
	 ASSIGNEQUAL|TIMESEQUAL|DIVIDEEQUAL|MODEQUAL|PLUSEQUAL|MINUSEQUAL|
	 SHIFTLEFTEQUAL|SHIFTRIGHTEQUAL|BITWISEANDEQUAL|BITWISEXOREQUAL|BITWISEOREQUAL|
	 EQUAL|NOTEQUAL|LESSTHAN|GREATERTHAN|LESSTHANOREQUALTO|GREATERTHANOREQUALTO|OR|AND|
	 PLUSPLUS|MINUSMINUS|COMMA|POINTERTO|POINTERTOMBR
	
	
	;


/*
 * Lexer. 
 */


// Operators:

terminal ASSIGNEQUAL     : '=' ;
terminal COLON           : ':' ;
terminal COMMA           : ',' ;
terminal QUESTIONMARK    : '?' ;
terminal SEMICOLON       : ';' ;
terminal POINTERTO       : '->' ;

// DOT & ELLIPSIS are commented out since they are generated as part of
// the Number rule below due to some bizarre lexical ambiguity shme.
terminal  DOT  :       '.' ;
terminal  ELLIPSIS      : '...' ;

terminal LPAREN          : '(' ;
terminal RPAREN          : ')' ;
terminal LSQUARE         : '[' ;
terminal RSQUARE         : ']' ;
terminal LCURLY          : '{' ;
terminal RCURLY          : '}' ;

terminal EQUAL           : '==' ;
terminal NOTEQUAL        : '!=' ;
terminal LESSTHANOREQUALTO     : '<=' ;
terminal LESSTHAN              : '<' ;
terminal GREATERTHANOREQUALTO  : '>=' ;
terminal GREATERTHAN           : '>' ;

terminal DIVIDE          : '/' ;
terminal DIVIDEEQUAL     : '/=' ;
terminal PLUS            : '+' ;
terminal PLUSEQUAL       : '+=' ;
terminal PLUSPLUS        : '++' ;
terminal MINUS           : '-' ;
terminal MINUSEQUAL      : '-=' ;
terminal MINUSMINUS      : '--' ;
terminal STAR            : '*' ;
terminal TIMESEQUAL      : '*=' ;
terminal MOD             : '%' ;
terminal MODEQUAL        : '%=' ;
terminal SHIFTRIGHT      : '>>' ;
terminal SHIFTRIGHTEQUAL : '>>=' ;
terminal SHIFTLEFT       : '<<' ;
terminal SHIFTLEFTEQUAL  : '<<=' ;

terminal AND            : '&&' ;
terminal NOT            : '!' ;
terminal OR             : '||' ;

terminal AMPERSAND       : '&' ;
terminal BITWISEANDEQUAL : '&=' ;
terminal TILDE           : '~' ;
//BITWISEAND      : ' & ' ;
terminal BITWISEOR       : '|' ;
terminal BITWISEOREQUAL  : '|=' ;
terminal BITWISEXOR      : '^' ;
terminal BITWISEXOREQUAL : '^=' ;

//Zuo: the following tokens are come from cplusplus.g

terminal POINTERTOMBR    : '->*' ;
terminal DOTMBR          : '.*'  ;

terminal SCOPE           : '::'  ;

terminal Whitespace	
	:	
		(	// Ignore space
			Space
		|	// handle newlines
			(	'\r' '\n'	// MS
			|	'\r'		// Mac
			|	'\n'		// Unix 
			)	
		|	// handle continuation lines
			(	'\\' '\r' '\n'	// MS
			|	'\\' '\r'		// Mac
			|	'\\' '\n'		// Unix 
			)	
		)	
		//{ $channel=HIDDEN; }
	;

terminal Comment  
	:	'/*' -> '*/';

terminal CPPComment
	:	
		'//' (!('\n' | '\r'))* EndOfLine
 		//{ $channel=HIDDEN; }                     
	;

terminal PREPROC_DIRECTIVE
	:	
		'#' LineDirective
		//{ $channel=HIDDEN; } 
	;

terminal fragment 
LineDirective
	:
		('line')?  // this would be for if the directive started '#line'
		(Space)+
		Decimal
		(Space)+
		(StringLiteral)
		((Space)+ Decimal)*	// To support cpp flags (GNU)
		EndOfLine?
	;

terminal fragment  
Space
	:	
			(' '|'\t') // |'\f')
	;

//terminal Pragma
//	:	
//		('#' 'pragma'	(	EndOfContinuedLine
//						|	!('\r' | '\n')
//						)*
//		EndOfLine?
//		)
//		//{ $channel=HIDDEN; }
//	;
terminal Pragma
	:	
		('#' 'pragma'	(	EndOfContinuedLine | '\\' (Space)* !('\r' | '\n' | Space)
						|	!('\r' | '\n' | '\\')
						)*
		EndOfLine?
		)
		//{ $channel=HIDDEN; }
	;

terminal Error
	:	
		('#' 'error'	(	EndOfContinuedLine | '\\' (Space)* !('\r' | '\n' | Space)
						|	!('\r' | '\n' | '\\')
						)* //EndOfLine
		EndOfLine?
		)
		//{ $channel=HIDDEN; }
	;


// Added by V3-Author to eliminate the need for a preprocessor
terminal PreProcDirective
		:
			('#' 
				Space*
				(
					'ifdef'	 		
				|	'ifndef' 		
				|	'if' 	  		
				|	'elif' 	 		
				|	'else' 	 		
				|	'endif'	 			
				|	'undef'    
				|	'define' 
				|	'exec_macro_expression' 
				|	'include'
				|	'include_next'	
				|	'warning' 
				)	
				
				(Space (	EndOfContinuedLine | '\\' (Space)* !('\r' | '\n' | Space)
					|	!('\r' | '\n' | '\\')
				)*)?
			EndOfLine?
			)
		//{ $channel=HIDDEN; }
		;

// Literals:

/*
 * Note that we do NOT handle tri-graphs nor multi-byte sequences.
 */

/*
 * Note that we can't have empty character constants (even though we
 * can have empty strings :-).
 */
terminal CharLiteral
	:	
		'\'' ( Escape | UniversalCharacterName | !('\''|'\\'|'\n'|'\r') ) '\''
	;

terminal WCharLiteral
	:
		'L' CharLiteral
	;

/*
 * Can't have raw imbedded newlines in string constants.  Strict reading of
 * the standard gives odd dichotomy between newlines & carriage returns.
 * Go figure.
 */
terminal StringLiteral
	:	
		'"'
		(	Escape
		|	UniversalCharacterName
		|	!('"'|'\\'|'\n'|'\r')
		)*
		'"'
	;

terminal WStringLiteral
	:
		'L' StringLiteral
	;

terminal fragment
EndOfContinuedLine
	:
		(
			'\\' (Space)* '\r' '\n'?	// MS
//		|	'\\' (Space)* '\r'		// Mac
		|	'\\' (Space)* '\n'		// Unix 
		)
	;

terminal fragment
EndOfLine
	:	
		(
			'\r' '\n'?  // MS
//		|	'\r'    // Mac
		|	'\n'    // Unix
		)
	;

/*
 * Handle the various escape sequences.
 *
 * Note carefully that these numeric escape *sequences* are *not* of the
 * same form as the C language numeric *constants*.
 *
 * There is no such thing as a binary numeric escape sequence.
 *
 * Octal escape sequences are either 1, 2, or 3 octal digits exactly.
 *
 * There is no such thing as a decimal escape sequence.
 *
 * Hexadecimal escape sequences are begun with a leading \x and continue
 * until a non-hexadecimal character is found.
 *
 * No real handling of tri-graph sequences, yet.
 */

terminal fragment
Escape  
	:	
		'\\'
		(
		  'a'
		| 'b'
		| 'f'
		| 'n'
		| 'r'
		| 't'
		| 'v'
		| '"'
		| '\''
		| '\\'
		| '?'
		| ('0'..'3') (
		 Digit (
		  Digit)? )?
		| ('4'..'7') (
		Digit)?
		| 'x' (
		 HexadecimalDigit)+ //Digit | 'a'..'f' | 'A'..'F')+
		)
	;

// Numeric Constants: 


terminal fragment
Digit
	:	
		'0'..'9'
	;

terminal fragment
Decimal
	:	
		('0'..'9')+
	;

terminal fragment
LongSuffix
	:	'l'
	|	'L'
	;

terminal fragment
UnsignedSuffix
	:	'u'
	|	'U'
	;

terminal fragment
FloatSuffix
	:	'f'
	|	'F'
	;

terminal fragment
Exponent
	:	
		('e'|'E') ('+'|'-')? (Digit)+
	;

terminal fragment
UniversalCharacterName
	:
		'\\u' HexQuad
	|	'\\U' HexQuad HexQuad
	;

terminal fragment
HexQuad
	:
		HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit 
	;

terminal fragment
HexadecimalDigit
	:
		('0'..'9'|'a'..'f'|'A'..'F')
	;

terminal fragment
Vocabulary
	:	
		'\u0009'..'\u000a' | '\u000d'..'\u0377' // je retire le c et 3 4 5 6 7 8 b
	;

/* terminal Number
	:	
		
		(Digit)+
		( '.' (Digit)* (Exponent)?  //Zuo 3/12/01
		| Exponent                  //Zuo 3/12/01
		)                          
		(FloatSuffix               
		|LongSuffix                
		)?
	|	
		'...'            
	|	
		'.'                        
		(	(Digit)+ (Exponent)?    //Zuo 3/12/01
			(FloatSuffix           
			|LongSuffix            
			)?
		)?
	|	
		'0' ('0'..'7')*            
		(LongSuffix                
		|UnsignedSuffix            
		)*                         
	|	
		'1'..'9' (Digit)*          
		(LongSuffix                
		|UnsignedSuffix            
		)*                         
	|	
		'0' ('x' | 'X') (HexadecimalDigit)+ //('a'..'f' | 'A'..'F' | Digit)+
		(LongSuffix                
		|UnsignedSuffix            
		)*                         
	;*/

//ID : ["a"-"z","A"-"Z", "_"] (["a"-"z","A"-"Z","0"-"9","_"])*;
terminal ID
	:

	/* ASM OSEF	('asm'|'_asm'|'__asm') 
			(EndOfLine
			|Space
			)+
		(
			LPAREN
				(	EndOfLine
				|	~(')' | '\r' | '\n')
				)*	
			RPAREN { $channel=HIDDEN; }
		|
			LCURLY
				(	EndOfLine
				|	~('}' | '\r' | '\n')
				)*	
			RCURLY { $channel=HIDDEN; }
		|
			// Single line asm statement
			(~('(' | ')' | '{' | '}' | '\n' | '\r' | ' ' | '\t' )) //| '\f'))
			(~('(' | ')' | '{' | '}' | '\n' | '\r'))* (EndOfLine)?
			{ $channel=HIDDEN; }
		)
	|*/	
		('a'..'z'|'A'..'Z'|'_')
		('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
	;


/*
CHARACTER : "'"
   (   (~["'","\\","\n","\r"])
   | ("\\" (
             ["n","t","v","b","r","f","a","\\","?","'","\""]
            |
             "0" (["0"-"7"])*
            |
             ["1"-"9"] (["0"-"9"])*
            |
             ("0x" | "0X") (["0"-"9","a"-"f","A"-"F"])+
           )
     )
   )
   "'";
STRING : "\""
   ( ( ~["\"","\\","\n","\r"])
   | ("\\" (
             ["n","t","v","b","r","f","a","\\","?","'","\""]
            |
             "0" (["0"-"7"])*
            |
             ["1"-"9"] (["0"-"9"])*
            |
             ("0x" | "0X") (["0"-"9","a"-"f","A"-"F"])+
           )
     )
   )*
   "\"";
*/




// ce ne sont pas des fragment... car utilisés par certaines règles !
terminal 
OCTALINT: '0' ('0'..'7')* ('u'|'U'|'l'|'L')?;

terminal 
DECIMALINT: '1'..'9' ('0'..'9')* ('u'|'U'|'l'|'L')? ;

terminal 
HEXADECIMALINT: ('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F')+ ('u'|'U'|'l'|'L')? ;

terminal 
//FLOATONE:(('0'..'9')+ '.' ('0'..'9')* | ('0'..'9')* '.' ('0'..'9')+)
//   (('e'|'E') ('-'|'+')? ('0'..'9')+)? ('f'|'F'|'l'|'L')?;
FLOATONE:(('0'..'9')+ '.' ('0'..'9')* | '.' ('0'..'9')+)
   (('e'|'E') ('-'|'+')? ('0'..'9')+)? ('f'|'F'|'l'|'L')?;

terminal 
FLOATTWO:('0'..'9')+ ('e'|'E') ('-'|'+')?  ('0'..'9')+ ('f'|'F'|'l'|'L')?;


/**
 * 4/6/2012
 * MAME GRAMMAR
 */

mame_root returns MameRoot: mame_declaration | mame_simple_block | mame_block | mame_interface;

mame_declaration returns MameDeclaration: name=mame_macro_description LPAREN exprList=expression_list RPAREN;

mame_block returns MameBlock : isStatic?='static'? start=mame_macro_start LPAREN exprList=expression_list RPAREN (statements+=mame_statement)*  end=mame_macro_end;

mame_simple_block returns MameSimpleBlock : isStatic?='static'? start=mame_macro_startend LPAREN exprList=expression_list RPAREN;

// static I8255A_INTERFACE( konami_ppi8255_0_intf )
mame_interface returns MameInterface : 'static' name=qualified_id LPAREN exprList=expression_list RPAREN LCURLY (content=interface_content)? RCURLY SEMICOLON;

//mame_interface returns MameInterface : 'static' qualifiedType=qualified_type LPAREN exprList=expression_list RPAREN value=initializer SEMICOLON;



// là c'est une formule C++ classique, mais l'enum/grammar mame_macro_interface n'est pas comprise... du coup j'écris cette règle.
//static const ay8910_interface frogger_ay8910_interface =
//| 'static' 'const' name=mame_macro_interface exprList=expression_list ASSIGNEQUAL LCURLY (content=interface_content)? RCURLY SEMICOLON;

interface_content returns InterfaceList :
list+=interface_subcontent (COMMA list+=interface_subcontent)*;

interface_subcontent returns InterfaceContent :
// {RES_K(5.1), RES_K(5.1), RES_K(5.1)}
LCURLY sub=interface_content RCURLY
|statement=mame_statement;



// MCFG_SOUND_ROUTES_RESET()
mame_statement returns MameStatement: name_call=mame_macro_call (LPAREN RPAREN)? | name_function=mame_macro_fonction LPAREN exprList=expression_list RPAREN;

// au même niveau que START et END, mais en une seule ligne
mame_macro_startend :
'GFXLAYOUT_RAW';

// a ne plus utiliser : ce sont de simples qualified_id
//mame_macro_interface :
//'I8255A_INTERFACE'
//|'ay8910_interface'
//|'Z80DMA_INTERFACE'
//|'I8257_INTERFACE'
//;

// *_START
mame_macro_start :
'MACHINE_CONFIG_START'
|'MACHINE_CONFIG_DERIVED'
|'MACHINE_CONFIG_FRAGMENT'
|'ADDRESS_MAP_START'
|'INPUT_PORTS_START'
|'ROM_START'
|'GFXDECODE_START'
|'DISCRETE_SOUND_START'
;

// *_END
mame_macro_end :
'ADDRESS_MAP_END'
|'MACHINE_CONFIG_END'
|'INPUT_PORTS_END'
|'MACHINE_CONFIG_END'
|'ROM_END'
|'GFXDECODE_END'
|'DISCRETE_SOUND_END'
;

// fonctions entre START et END
mame_macro_fonction returns mame_macro_fonction: 
gfx=EnumGFX_function
| intf=EnumINTF_function
| am=EnumAM_function
| rom=EnumROM_function
| port=EnumPORT_function
| cfg=EnumMCFG_function
| discr=EnumDISCR_function
;

// mots-clés entre START et END
mame_macro_call returns mame_macro_call ://ecore::EString :
intf=EnumINTF_call
| port=EnumPORT_call
| am=EnumAM_call
| cfg=EnumMCFG_call
| discr=EnumDISCR_call
;

enum EnumINTF_call :
DEVCB_NULL='DEVCB_NULL'
|DISC_MIXER_IS_OP_AMP='DISC_MIXER_IS_OP_AMP'
;

enum EnumAM_call :
AM_UNMAP='AM_UNMAP'
|AM_RAM='AM_RAM'
|AM_ROM='AM_ROM'
|AM_WRITEONLY='AM_WRITEONLY'
|AM_NOP='AM_NOP'
|AM_READNOP='AM_READNOP'
|AM_WRITENOP='AM_WRITENOP'
|ADDRESS_MAP_UNMAP_LOW='ADDRESS_MAP_UNMAP_LOW'
|ADDRESS_MAP_UNMAP_HIGH='ADDRESS_MAP_UNMAP_HIGH'
;
enum EnumPORT_call :
PORT_INVERT='PORT_INVERT'
|PORT_8WAY='PORT_8WAY'
|PORT_4WAY='PORT_4WAY'
|PORT_2WAY='PORT_2WAY'
|PORT_TOGGLE='PORT_TOGGLE'
|PORT_REVERSE='PORT_REVERSE'
|PORT_COCKTAIL='PORT_COCKTAIL'
|PORT_RESET='PORT_RESET'
;

// MCFG_SOUND_ROUTES_RESET()
enum EnumMCFG_call :
MCFG_SOUND_ROUTES_RESET='MCFG_SOUND_ROUTES_RESET'
|AY8910_DISCRETE_OUTPUT='AY8910_DISCRETE_OUTPUT'
|AY8910_LEGACY_OUTPUT='AY8910_LEGACY_OUTPUT'
|AY8910_DEFAULT_LOADS='AY8910_DEFAULT_LOADS'
;

enum EnumINTF_function :
DEVCB_INPUT_PORT='DEVCB_INPUT_PORT'
|DEVCB_HANDLER='DEVCB_HANDLER'
|DEVCB_DRIVER_MEMBER='DEVCB_DRIVER_MEMBER'
|DEVCB_DEVICE_HANDLER='DEVCB_DEVICE_HANDLER'
|DEVCB_CPU_INPUT_LINE='DEVCB_CPU_INPUT_LINE'
|DEVCB_MEMORY_HANDLER='DEVCB_MEMORY_HANDLER'
|RES_K='RES_K'
;

enum EnumDISCR_call :
DISCRETE_TASK_END='DISCRETE_TASK_END'
|DISCRETE_REPLACE='DISCRETE_REPLACE'
;

enum EnumDISCR_function :
DISCRETE_INPUTX_STREAM='DISCRETE_INPUTX_STREAM'
|DISCRETE_INPUT_DATA='DISCRETE_INPUT_DATA'
|DISCRETE_INPUT_LOGIC='DISCRETE_INPUT_LOGIC'
|DISCRETE_INPUTX_DATA='DISCRETE_INPUTX_DATA'
|DISCRETE_RCFILTER_SW='DISCRETE_RCFILTER_SW'
|DISCRETE_RCFILTER='DISCRETE_RCFILTER'
|DISCRETE_CRFILTER='DISCRETE_CRFILTER'
|DISCRETE_RCDISC5='DISCRETE_RCDISC5'
|DISCRETE_MIXER6='DISCRETE_MIXER6'
|DISCRETE_OUTPUT='DISCRETE_OUTPUT'
|DISCRETE_TASK_START='DISCRETE_TASK_START'
|DISCRETE_LFSR_NOISE='DISCRETE_LFSR_NOISE'
|DISCRETE_SQUAREWFIX='DISCRETE_SQUAREWFIX'
|DISCRETE_LOGIC_DFLIPFLOP='DISCRETE_LOGIC_DFLIPFLOP'
|DISCRETE_LOGIC_INVERT='DISCRETE_LOGIC_INVERT'
|DISCRETE_DAC_R1='DISCRETE_DAC_R1'
|DISCRETE_555_CC='DISCRETE_555_CC'
|DISCRETE_555_ASTABLE_CV='DISCRETE_555_ASTABLE_CV'
|DISCRETE_MULTADD='DISCRETE_MULTADD'
|DISCRETE_CLAMP='DISCRETE_CLAMP'
|DISCRETE_MIXER3='DISCRETE_MIXER3'
|DISCRETE_MIXER5='DISCRETE_MIXER5'
|DISCRETE_MIXER7='DISCRETE_MIXER7'
|DISCRETE_NOTE='DISCRETE_NOTE'
|DISCRETE_BITS_DECODE='DISCRETE_BITS_DECODE'
|DISCRETE_OP_AMP_FILTER='DISCRETE_OP_AMP_FILTER'
|DISCRETE_MULTIPLY='DISCRETE_MULTIPLY'
|DISCRETE_TRANSFORM5='DISCRETE_TRANSFORM5'

|DISCRETE_IMPORT='DISCRETE_IMPORT'
|DISCRETE_DELETE='DISCRETE_DELETE'

;

enum EnumGFX_function :
GFXDECODE_ENTRY='GFXDECODE_ENTRY'
|GFXDECODE_SCALE='GFXDECODE_SCALE'
;

enum EnumMCFG_function :
MCFG_CPU_ADD='MCFG_CPU_ADD'
|MCFG_CPU_PROGRAM_MAP='MCFG_CPU_PROGRAM_MAP'
|MCFG_CPU_MODIFY='MCFG_CPU_MODIFY'
|MCFG_CPU_CONFIG='MCFG_CPU_CONFIG'
|MCFG_CPU_REPLACE='MCFG_CPU_REPLACE'
|MCFG_CPU_IO_MAP='MCFG_CPU_IO_MAP'
|MCFG_CPU_VBLANK_INT='MCFG_CPU_VBLANK_INT'
|MCFG_CPU_PERIODIC_INT='MCFG_CPU_PERIODIC_INT'
|MCFG_Z80DMA_ADD='MCFG_Z80DMA_ADD'
|MCFG_MACHINE_START='MCFG_MACHINE_START'
|MCFG_MACHINE_RESET='MCFG_MACHINE_RESET'
|MCFG_SCREEN_ADD='MCFG_SCREEN_ADD'
|MCFG_SCREEN_MODIFY='MCFG_SCREEN_MODIFY'
|MCFG_SCREEN_TYPE='MCFG_SCREEN_TYPE'
|MCFG_SCREEN_RAW_PARAMS='MCFG_SCREEN_RAW_PARAMS'
|MCFG_SCREEN_REFRESH_RATE='MCFG_SCREEN_REFRESH_RATE'
|MCFG_SCREEN_VBLANK_TIME='MCFG_SCREEN_VBLANK_TIME'
|MCFG_SCREEN_SIZE='MCFG_SCREEN_SIZE'
|MCFG_SCREEN_VISIBLE_AREA='MCFG_SCREEN_VISIBLE_AREA'
|MCFG_SCREEN_DEFAULT_POSITION='MCFG_SCREEN_DEFAULT_POSITION'
|MCFG_SCREEN_UPDATE_STATIC='MCFG_SCREEN_UPDATE_STATIC'
|MCFG_SCREEN_UPDATE_DRIVER='MCFG_SCREEN_UPDATE_DRIVER'
|MCFG_SCREEN_UPDATE_DEVICE='MCFG_SCREEN_UPDATE_DEVICE'
|MCFG_SCREEN_VBLANK_NONE='MCFG_SCREEN_VBLANK_NONE'
|MCFG_SCREEN_VBLANK_STATIC='MCFG_SCREEN_VBLANK_STATIC'
|MCFG_SCREEN_VBLANK_DRIVER='MCFG_SCREEN_VBLANK_DRIVER'
|MCFG_SCREEN_VBLANK_DEVICE='MCFG_SCREEN_VBLANK_DEVICE'
|MCFG_PALETTE_LENGTH='MCFG_PALETTE_LENGTH'
|MCFG_PALETTE_INIT='MCFG_PALETTE_INIT'
|MCFG_QUANTUM_TIME='MCFG_QUANTUM_TIME'
|MCFG_QUANTUM_PERFECT_CPU='MCFG_QUANTUM_PERFECT_CPU'
|MCFG_WATCHDOG_VBLANK_INIT='MCFG_WATCHDOG_VBLANK_INIT'
|MCFG_WATCHDOG_TIME_INIT='MCFG_WATCHDOG_TIME_INIT'
|MCFG_NVRAM_HANDLER='MCFG_NVRAM_HANDLER'
|MCFG_MEMCARD_HANDLER='MCFG_MEMCARD_HANDLER'
|MCFG_VIDEO_START='MCFG_VIDEO_START'
|MCFG_MB14241_ADD='MCFG_MB14241_ADD'
|MCFG_FRAGMENT_ADD='MCFG_FRAGMENT_ADD'
|MCFG_SPEAKER_STANDARD_MONO='MCFG_SPEAKER_STANDARD_MONO'
|MCFG_SOUND_ADD='MCFG_SOUND_ADD'
|MCFG_SOUND_CONFIG='MCFG_SOUND_CONFIG'
|MCFG_SOUND_ROUTE='MCFG_SOUND_ROUTE'
|MCFG_SOUND_REPLACE='MCFG_SOUND_REPLACE'
|MCFG_SOUND_START='MCFG_SOUND_START'
|MCFG_SOUND_ROUTE_EX='MCFG_SOUND_ROUTE_EX'
|MCFG_SOUND_CONFIG_DISCRETE='MCFG_SOUND_CONFIG_DISCRETE'
|MCFG_EEPROM_93C66B_ADD='MCFG_EEPROM_93C66B_ADD'
|MCFG_SPEAKER_STANDARD_STEREO='MCFG_SPEAKER_STANDARD_STEREO'
|MCFG_GFXDECODE='MCFG_GFXDECODE'
|MCFG_DEVICE_ADD='MCFG_DEVICE_ADD'
|MCFG_DEVICE_REMOVE='MCFG_DEVICE_REMOVE'
|MCFG_DEVICE_REPLACE='MCFG_DEVICE_REPLACE'
|MCFG_DEVICE_MODIFY='MCFG_DEVICE_MODIFY'
|MCFG_DEVICE_CONFIG='MCFG_DEVICE_CONFIG'
|MCFG_VIDEO_ATTRIBUTES='MCFG_VIDEO_ATTRIBUTES'
|MCFG_NVRAM_ADD_0FILL='MCFG_NVRAM_ADD_0FILL'
|MCFG_K052109_ADD='MCFG_K052109_ADD'
|MCFG_K053245_ADD='MCFG_K053245_ADD'
|MCFG_K051960_ADD='MCFG_K051960_ADD'
|MCFG_K053251_ADD='MCFG_K053251_ADD'
|MCFG_K054000_ADD='MCFG_K054000_ADD'
|MCFG_K053936_ADD='MCFG_K053936_ADD'
|MCFG_K054539_ADD='MCFG_K054539_ADD'
|MCFG_OKIM6295_ADD='MCFG_OKIM6295_ADD'
|MCFG_SAMPLES_ADD='MCFG_SAMPLES_ADD'
|MCFG_EEPROM_ADD='MCFG_EEPROM_ADD'
|MCFG_I8255A_ADD='MCFG_I8255A_ADD'
|MCFG_I8257_ADD='MCFG_I8257_ADD'
|MCFG_TIMER_ADD='MCFG_TIMER_ADD'
|MCFG_TIMER_ADD_PERIODIC='MCFG_TIMER_ADD_PERIODIC'
|MCFG_TIMER_ADD_SCANLINE='MCFG_TIMER_ADD_SCANLINE'
|MCFG_TIMER_MODIFY='MCFG_TIMER_MODIFY'
|MCFG_TIMER_CALLBACK='MCFG_TIMER_CALLBACK'
|MCFG_TIMER_START_DELAY='MCFG_TIMER_START_DELAY'
|MCFG_TIMER_PARAM='MCFG_TIMER_PARAM'
|MCFG_TIMER_PTR='MCFG_TIMER_PTR'
|MCFG_SOUND_MODIFY='MCFG_SOUND_MODIFY'
|MCFG_WILLIAMS_ADPCM_SOUND_ADD='MCFG_WILLIAMS_ADPCM_SOUND_ADD'
|MCFG_DEFAULT_LAYOUT='MCFG_DEFAULT_LAYOUT'
;

enum EnumPORT_function :
PORT_START='PORT_START'
|PORT_BIT='PORT_BIT'
|PORT_CUSTOM_MEMBER='PORT_CUSTOM_MEMBER'
|PORT_POSITIONS='PORT_POSITIONS'
|PORT_REMAP_TABLE='PORT_REMAP_TABLE'
|PORT_SENSITIVITY='PORT_SENSITIVITY'
|PORT_KEYDELTA='PORT_KEYDELTA'
|PORT_CENTERDELTA='PORT_CENTERDELTA'
|PORT_NAME='PORT_NAME'
|PORT_CROSSHAIR='PORT_CROSSHAIR'
|PORT_PLAYER='PORT_PLAYER'
|PORT_DIPNAME='PORT_DIPNAME'
|PORT_CONDITION='PORT_CONDITION'
|PORT_DIPLOCATION='PORT_DIPLOCATION'
|PORT_DIPSETTING='PORT_DIPSETTING'
|PORT_CODE='PORT_CODE'
|PORT_CODE_DEC='PORT_CODE_DEC'
|PORT_CODE_INC='PORT_CODE_INC'
|PORT_SERVICE_DIPLOC='PORT_SERVICE_DIPLOC'
|PORT_CONFNAME='PORT_CONFNAME'
|PORT_CONFSETTING='PORT_CONFSETTING'
|PORT_MINMAX='PORT_MINMAX'
|PORT_ADJUSTER='PORT_ADJUSTER'
|PORT_INCLUDE='PORT_INCLUDE'
|PORT_MODIFY='PORT_MODIFY'
|PORT_DIPUNUSED='PORT_DIPUNUSED'
|PORT_SERVICE_NO_TOGGLE='PORT_SERVICE_NO_TOGGLE'
|PORT_IMPULSE='PORT_IMPULSE'
|PORT_SERVICE='PORT_SERVICE'
|PORT_DIPUNKNOWN_DIPLOC='PORT_DIPUNKNOWN_DIPLOC'
|PORT_VBLANK='PORT_VBLANK'
|PORT_DIPUNUSED_DIPLOC='PORT_DIPUNUSED_DIPLOC'
|PORT_WRITE_LINE_DEVICE_MEMBER='PORT_WRITE_LINE_DEVICE_MEMBER'
|PORT_READ_LINE_DEVICE_MEMBER='PORT_READ_LINE_DEVICE_MEMBER'
|KONAMI16_LSB='KONAMI16_LSB' //PORT
|KONAMI16_MSB='KONAMI16_MSB' //PORT
|KONAMI_COINAGE_LOC='KONAMI_COINAGE_LOC' //PORT
|PORT_DIPUNKNOWN='PORT_DIPUNKNOWN'
|PORT_CHANGED_MEMBER='PORT_CHANGED_MEMBER'
;

enum EnumROM_function :
ROM_REGION='ROM_REGION'
|ROM_LOAD='ROM_LOAD'
|ROM_LOAD16_BYTE='ROM_LOAD16_BYTE'
|ROM_LOAD32_BYTE='ROM_LOAD32_BYTE'
|ROM_LOAD16_WORD='ROM_LOAD16_WORD'
|ROM_LOAD32_WORD='ROM_LOAD32_WORD'
|ROM_CONTINUE='ROM_CONTINUE'
|ROM_REGION32_LE='ROM_REGION32_LE'
|ROM_REGION16_LE='ROM_REGION16_LE'
|ROM_REGION16_BE='ROM_REGION16_BE'
|ROM_RELOAD='ROM_RELOAD'
|ROM_LOAD16_WORD_SWAP='ROM_LOAD16_WORD_SWAP'
|ROM_IGNORE='ROM_IGNORE'
|ROM_COPY='ROM_COPY'
|ROM_LOAD_NIB_LOW='ROM_LOAD_NIB_LOW'
|ROM_LOAD_NIB_HIGH='ROM_LOAD_NIB_HIGH'
|ROM_FILL='ROM_FILL'
|DISK_REGION='DISK_REGION'
|DISK_IMAGE='DISK_IMAGE'
;

enum EnumAM_function :
AM_RANGE='AM_RANGE'
|AM_READ='AM_READ'
|AM_READ_LEGACY='AM_READ_LEGACY'
|AM_WRITE8='AM_WRITE8'
|AM_WRITE='AM_WRITE'
|AM_WRITE_LEGACY='AM_WRITE_LEGACY'
|AM_READWRITE='AM_READWRITE'
|AM_READWRITE8='AM_READWRITE8'
|AM_READWRITE_LEGACY='AM_READWRITE_LEGACY'
|AM_READ_PORT='AM_READ_PORT'
|AM_DEVREAD='AM_DEVREAD'
|AM_DEVREAD_LEGACY='AM_DEVREAD_LEGACY'
|AM_DEVREAD8_LEGACY='AM_DEVREAD8_LEGACY'
|AM_DEVWRITE='AM_DEVWRITE'
|AM_DEVWRITE_LEGACY='AM_DEVWRITE_LEGACY'
|AM_DEVWRITE8_LEGACY='AM_DEVWRITE8_LEGACY'
|AM_DEVREADWRITE='AM_DEVREADWRITE'
|AM_DEVREADWRITE_LEGACY='AM_DEVREADWRITE_LEGACY'
|AM_DEVREADWRITE8='AM_DEVREADWRITE8'
|AM_DEVREADWRITE8_LEGACY='AM_DEVREADWRITE8_LEGACY'
|AM_MASK='AM_MASK'
|AM_MIRROR='AM_MIRROR'
|AM_REGION='AM_REGION'
|AM_SHARE='AM_SHARE'
|AM_BASE='AM_BASE'
|AM_BASE_LEGACY='AM_BASE_LEGACY'
|AM_SIZE='AM_SIZE'
|AM_SIZE_LEGACY='AM_SIZE_LEGACY'
|AM_BASE_MEMBER='AM_BASE_MEMBER'
|AM_SIZE_MEMBER='AM_SIZE_MEMBER'
|AM_RAM_WRITE='AM_RAM_WRITE'
|AM_RAMBANK='AM_RAMBANK'
|AM_ROMBANK='AM_ROMBANK'
|ADDRESS_MAP_GLOBAL_MASK='ADDRESS_MAP_GLOBAL_MASK'
|AM_LATCH8_WRITE='AM_LATCH8_WRITE'
//NOT DOCUMENTED
|AM_IMPORT_FROM='AM_IMPORT_FROM'
;

mame_macro_description returns ecore::EString :
'GAME'
|'GAMEL';

mame_INLINE : 'INLINE';

mame_function returns MameFunc : 'FUNC' LPAREN qualifiedId=qualified_id RPAREN; // FUNC(handler) for code coverage

// TODO : ici je mélange les types et les déclarations de fonctions... du coup mame_terminals apparait deux fois dans la grammaire C++, pas bien :p
mame_terminals returns ecore::EString : 'BAD_DUMP'? CRC SHA1 | MAME_ID | OCTALINT |DECIMALINT ; // 1943

// interrupts http://mamedev.org/devwiki/index.php/MAME_Interrupt_Function_Review
mame_interrupt returns ecore::EString :
'ASSERT_LINE'
|'CLEAR_LINE'
|'PULSE_LINE'
|'HOLD_LINE'
;


terminal CRC: 'CRC(' ('a'..'f'|'A'..'Z'|'0'..'9')+ ')';
terminal SHA1: 'SHA1(' ('a'..'f'|'A'..'Z'|'0'..'9')+ ')';
terminal MAME_ID : ('0'..'9') ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'?')*; // 39in1 // 19??







	